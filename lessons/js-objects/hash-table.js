/* eslint-disable no-param-reassign */
// sc: https://ru.hexlet.io/courses/js-objects/lessons/hash-table/exercise_unit

// map.js

// Реализуйте и экспортируйте набор функций, для работы со словарём, построенным на хеш-таблице. Для
// простоты, наша реализация не поддерживает разрешение коллизий.

// По сути в этом задании надо реализовать объекты. По понятным причинам использовать объекты для
// создания объектов нельзя. Представьте что в языке объектов нет и мы их хотим добавить.

// make() — создаёт новый словарь
// set(map, key, value) — устанавливает в словарь значение по ключу.
// Работает и для создания и для изменения. Функция возвращает true, если удалось установить
// значение. При возникновении коллизии, функция никак не меняет словарь и возвращает false.
// get(map, key, defaultValue = null) — возвращает значение указанного ключа. Параметр defaultValue
// — значение, которое функция возвращает, если в словаре нет ключа (по умолчанию равно null). При
// возникновении коллизии функция также возвращает значение по умолчанию.

// Функции set и get принимают первым параметром словарь.
// Передача идёт по ссылке, поэтому set может изменить его напрямую.

// Для внутреннего представления словаря, используйте массив, где индекс содержит хеш записи, а
// значение — key и value (их можно упаковать в массив).
// Документация crc-32 https://github.com/SheetJS/js-crc32

// Алгоритмы из теории
// // 1. Создание ассоциативного массива приводит к инициализации индексированного массива внутри
// интерпретатора.
// const internal = [];
// // Во время присвоения значения `data['key'] = 'value'`, интерпретатор выполняет несколько
// действий:
// // 2. Хеширует ключ. Результатом хеширования становится число. const hash = crc32.str('key'); //
// 3. Число, полученное на предыдущем шаге преобразуется в индекс массива. const index =
// Math.abs(hash) % 1000; // В значение внутреннего индексированного массива, по найденному индексу,
// записывается ещё один массив, // первым элементом которого становится ключ `'key'`, а вторым
// значение `'value'`. internal[index] = ['key', 'value'];

// // 1. Хеширует ключ. Результатом хеширования становится число.
// const hash = crc32.str('key');
// // 2. Число, полученное на предыдущем шаге преобразуется в индекс массива.
// const index = Math.abs(hash % 1000);
// // 3. Если индекс существует, то извлекается значение, которое находилось внутри, и возвращается
// наружу.
// return internal[index];

const getHashIndex = (key) => {
  const hash = crc32.str(key);
  const index = Math.abs(hash) % 1000;
  return index;
};
const isCollision = (map, index, key) => {
  const [oldKey] = map[index];
  return key !== oldKey;
};

const make = () => [];
const set = (map, key, value) => {
  const index = getHashIndex(key);
  if (index in map && isCollision(map, index, key)) {
    return false;
  }
  map[index] = [key, value];
  return true;
};
const get = (map, key, defaultValue = null) => {
  const index = getHashIndex(key);
  if (index in map && !isCollision(map, index, key)) {
    const [, value] = map[index];
    return value;
  }
  return defaultValue;
};
export { make, set, get };
